# Agent 原生通讯协议：从传递代码，到传递认知

## 文档信息

- 站点：微信公众平台
- 原文链接：https://mp.weixin.qq.com/s/6ppTHXXdmKWI18uB_ysf3w
- 发布日期：2026-02-11
- 作者：歸藏的AI工具箱

## 摘要

### 1) 一句话总结
前 GitHub CEO 创立的 Entire 推出 Checkpoint 工具，通过在 Git 提交中结构化记录 AI Agent 的推理过程与上下文，填补了传统版本控制缺失的“决策原因”，旨在构建 Agent 原生的协作基础设施。

### 2) 核心要点
*   **现象演进**：GitHub 的 Issue 和 PR 凭借其纯文本、命令式、结构化和版本控制的特性，正自然演变为 AI Agent 之间隐式的通讯协议。
*   **商业动作**：前 GitHub CEO Thomas Dohmke 创立新公司 Entire，获得 6000 万美元种子轮融资，致力于在 Git 之上构建专为 Agent 设计的开发者平台。
*   **传统 Git 的局限**：现有 Git 体系忠实记录了代码变更的“是什么、谁做的、时间和地点”，但缺失了 Agent 生成代码时的“为什么（推理链和决策权衡）”。
*   **Checkpoint 机制**：Entire 发布的首个产品 Checkpoint 在 Git 之上增加语义元数据层，将原始 Prompt、推理链、工具调用、约束条件和 Token 消耗与具体的 commit SHA 绑定。
*   **兼容性设计**：Checkpoint 的元数据以 append-only（仅追加）的方式存储在独立的 Git 分支（`entire/checkpoints/v1`）上，完全兼容现有 Git 工作流且不影响代码本身。
*   **审查范式转变**：代码审查从“逐行阅读 diff”转变为“审查 Agent 的意图、推理过程和决策合理性”。
*   **角色转变**：开发者的核心职责从“编写代码的工人”转变为“表达意图并审查 Agent 思维过程的监督者”。
*   **产品架构规划**：Entire 规划了三层架构：已发布的 Checkpoint（存储层），以及待发布的 Context Graph（语义推理与检索层）和 AI 原生开发生命周期（实时协调与工作流）。

### 3) 风险与缺口
*   **上下文爆炸与检索难题**：长期运行的项目可能累积海量数据（如 10M tokens），超出 Agent 的上下文窗口限制。目前 Checkpoint 解决了存储问题，但 Agent 如何从海量历史中精准提取有效信息仍是挑战（计划通过未来的 Context Graph 解决）。
*   **缺乏实时协调机制**：Checkpoint 本质上是“事后记录（post-commit）”，在多 Agent 团队并行协作时，无法满足实时通讯与状态同步的需求，可能导致并行工作时的方案不兼容。

## 正文

当 Agent 开始用 Git 说话：从一个 Vibe Coding 开发者的发现，到 Agent 协作的未来。

### 一个意外的发现

最近我在维护自己的开源项目时，做了一件很自然的事：让 AI Agent 帮我处理 GitHub 上的 Issues 和 PR。

一开始只是图省事——Issue 太多了，让 Agent 帮我读一读、分分类、回复一些常见问题。PR 也是，让 Agent 先做一轮 Code Review，帮我过滤掉明显有问题的提交。

但很快我发现了一件有趣的事情：给我提 Issue 的，很多也是 Agent；给我提 PR 的，也是 Agent。**我的 Agent 在和别人的 Agent 对话。**

它们用 Issue 的格式交换需求，用 PR 的格式交换代码，用 Comment 的格式讨论方案。没有人刻意设计过这套流程，但它就这么自然地发生了。那一刻我意识到——**GitHub 正在无声无息地变成一种 Agent 之间的通讯协议。**

仔细想想，这并不意外。GitHub 天然具备 Agent 通讯协议所需要的一切特性：
*   **可读且安全**：纯文本，所有操作透明可审计。
*   **命令式的**：Issue 是任务指令，PR 是执行结果。
*   **结构化的**：标签、模板、状态流转，天然适合机器解析。
*   **有版本控制**：每一次交互都被记录，不会丢失。

Agent 不需要什么新协议，它们已经在用人类建造的最成熟的协作基础设施来互相沟通了。

### 巧合还是必然？

昨天我刚和朋友聊完这个观察，今天早上就看到一条新闻：GitHub 前 CEO Thomas Dohmke 宣布创立新公司 Entire，拿了 6000 万美元种子轮，要在 Git 之上构建 Agent 时代的开发者平台。

有时候你模糊感知到的趋势，突然被行业里最懂这件事的人用一家公司、一笔融资、一个产品确认了——这种感觉很奇妙。

Thomas Dohmke 在公告里写了一句话，和我的感受完全一致：
> "我们仍然依赖一个在云时代之前构建的软件开发生命周期，它天生是为人与人协作设计的。"

他看到的问题和我看到的一样：现有的 Git/GitHub 体系是为人设计的，Agent 在将就着用。能用，但不够。

### Entire 与 Checkpoint：给 Git 补上 "Why"

#### Git 记录了什么，遗漏了什么
先回顾一下现有的 Git 体系。Git 是一个极其优秀的版本控制系统，它忠实记录了：
*   **What**：哪些文件变了，每一行的 diff
*   **Who**：谁提交的
*   **When**：什么时候提交的
*   **Where**：在哪个分支上

但它有一个致命的缺失：**Why——为什么要这么改。**

在人类手写代码的时代，这个“为什么”勉强可以通过 commit message 和 PR description 来补充。但在 Agent 时代，这个缺失被放大了一百倍。Agent 生成了 500 行代码，你只看到 diff，完全不知道它的推理链；Agent 做了一个架构决策，选了方案 A 放弃了方案 B，你不知道权衡了什么。你给 Agent 的 prompt、约束、讨论过程，在关闭终端的那一刻全部消失。

Git 保存了代码怎么变的，但丢掉了代码为什么这么变。

#### Entire 的 Checkpoint
Entire 发布的第一个产品叫 Checkpoint。它的做法很聪明——不修改 Git，而是在 Git 之上增加一层语义元数据。

当你用 Agent 生成代码并 commit 时，Checkpoint 自动捕获并绑定到这个 commit SHA 上：

*   **普通 Git Commit**：`commit abc123` → diff（代码变更）
*   **Entire Checkpoint**：`commit abc123` → diff（代码变更） + 原始 prompt（指令） + 推理链（考虑与放弃了什么） + 工具调用（读了哪些文件/API） + 约束条件（兼容性限制） + token 消耗 + 完整对话记录。

这些元数据存储在一个独立的 Git 分支（`entire/checkpoints/v1`）上，以 append-only 的方式追加。代码本身不受任何影响，完全兼容现有的 Git 工作流。本质上，Checkpoint 把 Agent 的“想法”从黑箱变成了白箱——可追溯、可审查、可共享。

#### 为什么这件事比“存聊天记录”重要得多？
这不仅仅是把 AI 的聊天记录存到了 Git 里，区别在于它是结构化的、版本化的、绑定到代码变更的。这意味着：

1.  **代码审查的范式变了**：过去你打开 PR 逐行读几千行 diff。现在你可以先看 Checkpoint，了解 Agent 接到的意图、考虑的方案以及选择当前实现的原因。你审查的不再是“代码对不对”，而是“思维过程合不合理”。
2.  **Agent 之间有了共享记忆**：Agent A 做完技术选型后上下文消失，Agent B 接手时可以读取 Agent A 的 Checkpoint，直接继承决策和约束，无需从头推理。
3.  **决策历史可追溯**：三个月后如果有人问“为什么选了 SQLite 而不是 PostgreSQL”，直接查那个 commit 的 Checkpoint，当初的完整讨论和推理都在。

### 新范式：从“写代码的工人”到“审查思维的监督者”

Entire 和 Checkpoint 指向的，其实是一个更深层的范式转变。

**旧范式：**
> 开发者写代码 → commit → 开 PR → 同事看 diff → 讨论 → merge
*(代码是核心产物，人的注意力集中在“这段代码写得对不对”。)*

**新范式：**
> 表达意图 → Agent 生成 → Checkpoint 记录推理 → Review 意图和结果 → 验证正确性

每一步都发生了质变：
*   **表达意图**：开发者的第一步不再是写代码，而是用自然语言描述需求（如“需要一个 JWT 认证中间件...”）。意图本身成了工程产物。
*   **Agent 生成**：Agent 读项目、分析代码、权衡方案并生成代码。过去这些消耗大量算力的推理是瞬态的，现在被保留了下来。
*   **Checkpoint 记录推理**：推理过程被自动捕获，无需开发者手动写规则文件或技术文档。
*   **Review 意图和结果**：你不再逐行看代码，而是审查意图是否正确、决策是否合理、约束是否满足。你审查的是 Agent 的认知过程。
*   **验证正确性**：Agent 可以同时生成代码和测试，另一个 Agent 可以读取 Checkpoint 检查推理链是否自洽，业务指标自动验证结果。

一句话总结：**人的角色从“写代码的工人”变成了“审查 Agent 思维过程的监督者”。**

### 对 Agent 时代的意义

把 Entire 放到更大的背景下看，它的意义超越了一个开发工具。

**Agent 的世界需要自己的“互联网”**
旧世界里，HTTP 是人访问网站的协议；新世界里，Agent 需要自己的协作协议。目前 Agent 通过 Issues 和 PR 互相沟通是一种隐式的、低带宽的通讯。Entire 想做的是把这变成显式的、高带宽的通讯：不仅传代码，还传推理过程、上下文图谱、决策依据。这也是为什么 Entire 强调开源和独立，它在推行一个协议标准。

**从 2C、2B 到 2A**
过去软件服务消费者（2C）或企业（2B），未来最大的客户是 Agent（2A）。如果 Agent 是软件的新用户，Agent 之间的高效协作就是最关键的基础设施。Checkpoint 本质上就是让 Agent 协作“用得爽”的结构化推理数据。

**“韩信点兵”需要指挥体系**
未来人和人的差距，取决于你能驱动多少 Agent 为你工作。但驱动 100 个 Agent 如果没有协调体系，就会变成各自为战、重复推理的混乱。Entire 的三层架构对应的就是这个指挥体系：统一的信息存储、共享的态势感知、清晰的协作流程。

### 解决了什么，还有哪些挑战？

#### 已经解决的问题
*   **告别“人肉 Checkpoint”**：作为重度 Vibe Coding 开发者，以前 AI 经常遗忘上下文，我不得不手动维护规则文件（如 `CLAUDE.md`）来保存架构决策。现在 Checkpoint 自动绑定每次对话和推理链到 commit 上，成为永久历史。回复历史 Issue 时，也能直接引用当时的推理，有理有据。
*   **多 Agent 协作有了共享认知**：在复杂的 Git worktree 工作流中，审查多个 Agent Teams 的产出非常痛苦。Checkpoint 让我可以直接对比不同方案的推理摘要和决策依据，5 分钟就能做出判断，而不需要逐行对比 diff。

#### 尚未解决的问题
*   **上下文爆炸问题**：上下文窗口是有限的。一个运行三个月的项目可能累积 10M tokens 的数据，Agent 一次看不完。Checkpoint 解决了存储问题，但引入了检索问题——Agent 如何从海量历史中精准提取当前任务需要的有效信息？
*   **从事后记录到实时协调**：Checkpoint 本质上是“事后记录”。但在多 Agent 并行协作中，我们需要实时通讯。比如 Team 1 决定使用某种数据库，应该实时同步给并行的 Team 2，而不是等 commit 后才发现不兼容。

#### Entire 的解决思路
Entire 的完整愿景包含三层架构，恰好对应了这些挑战：

| 层次 | 解决什么 | 状态 |
| :--- | :--- | :--- |
| **Checkpoint（存储层）** | 信息不再丢失 | ✅ 已发布 |
| **Context Graph（语义推理层）** | 从海量 Checkpoint 中精准检索 | 🔜 待发布 |
| **AI 原生开发生命周期** | Agent 间的实时协调与工作流 | 🔜 待发布 |

Context Graph 可能是最关键的一层。它需要做到根据当前任务语义，智能检索并分层压缩历史上下文（完整记录、决策摘要、关键约束）。就像人的记忆有遗忘曲线和按需回忆一样，Agent 也需要类似的智能检索和压缩机制。

### 结语

回到最初的发现：Agent 已经在用 GitHub 互相沟通了，这件事正在自然发生。

Entire 做的事情，是把这种自然发生的通讯，从隐式变成显式，从低带宽变成高带宽，从“将就着用人类的工具”变成“为 Agent 时代专门设计的基础设施”。

Checkpoint 是第一步——把 Agent 的思维过程从黑箱变成白箱。接下来的 Context Graph 和 AI 原生开发生命周期，才是真正让 Agent 之间高效协作的关键。

但最深刻的变化在角色层面：**我们正在从“写代码的工人”变成“审查 Agent 思维过程的监督者”。**

你不需要理解每一行代码怎么写的，但需要理解 Agent 的推理是否合理、决策是否正确、有没有遗漏关键约束。这是一种全新的能力，也是一种全新的责任。

旧世界的开发者用键盘写代码。新世界的开发者用判断力指挥 Agent。而 Entire 这样的基础设施，就是让这种指挥成为可能的指挥系统。

地基已经打下，让我们看看上面能建起什么。

## 关联主题

- [[00-元语/Agent]]
- [[00-元语/protocol]]
- [[00-元语/github]]
