---
title: "如何在 Agent Builder 中使用记忆功能"

来源: "https://blog.langchain.com/how-to-use-memory-in-agent-builder/"
发布日期: "2026-02-19"
---

## 摘要

**1) 一句话总结**
Agent Builder 依托文件系统实现短期与长期记忆，用户可通过主动指示记忆、配置按需加载的“技能”以及直接编辑记忆文件三种方式，持续优化智能体的工作表现。

**2) 关键要点**
*   **底层架构**：Agent Builder 基于 LangChain 的开源框架 Deep Agents 构建，其记忆功能本质上是智能体可读写的文件系统。
*   **短期记忆**：仅在单次对话（线程）期间存在，包含任务计划、工具调用输出（如搜索结果）和任务进度等文件。
*   **长期记忆**：跨对话永久保留在特定路径（`/memories/`）下，使用标准的 Markdown 文件存储智能体的核心指令和技能。
*   **主动记忆**：用户可通过提示语（如“更新你的指令始终使用此方法”）直接要求智能体将有效的短期上下文保存为长期记忆。
*   **自动提议**：当用户给出明确反馈时，智能体会主动提议修改指令，并在保存前征求用户同意。
*   **技能（Skills）机制**：技能是一种按需加载的长期记忆，智能体仅在任务相关时才会调用特定的上下文（如特定产品的信息）。
*   **直接编辑**：用户可以直接访问并手动编辑智能体的指令和配置文件（即记忆文件）。
*   **编辑优势**：直接编辑有助于用户审查智能体的思维方式与优先级，且对于微调指令或更改任务运行时间等小幅更新，手动操作速度更快。

**3) 风险/缺口**
*   **幻觉风险（Hallucinations）**：如果智能体试图同时记住所有事情（加载过多无关上下文），可能会失去对当前任务重点的关注，从而导致幻觉。
*   **假设偏差**：智能体在处理问题时的优先级和假设可能与用户的实际预期不符，或包含不必要的步骤（需通过直接审查和编辑记忆来纠正）。

## 正文

Agent Builder 会随着使用次数的增加而变得越来越好，因为它能记住你的反馈。你做出的每一次修正、分享的偏好以及行之有效的方法，你的智能体（Agent）都能保留下来，并在下一次应用。

记忆功能让 Agent Builder 感觉就像一个真实的团队成员。但就像与任何团队成员合作一样，了解如何与他们有效沟通非常有帮助。以下是三种充分利用智能体记忆功能的实用方法。

### 记忆功能的工作原理

在深入了解这些技巧之前，了解其底层运作原理会很有帮助。

Agent Builder 是基于 Deep Agents 构建的，这是 LangChain 用于自主、长时间运行任务的开源智能体框架。你的智能体可以访问用于推理的大语言模型（LLM）、执行操作的工具（如网络搜索、Slack 或 Google Sheets）、生成子智能体的能力以及一个文件系统。

这个文件系统就是记忆存在的地方。记忆分为两种类型：

*   **短期记忆**：智能体在任务期间创建的文件，例如计划、工具调用的输出（如网络搜索结果）和任务进度。它们存在于对话（或线程）期间，但不会跨对话保留。
*   **长期记忆**：智能体保存到持久路径（`/memories/`）的文件。这些文件在所有对话中都会保留。智能体的核心指令和技能就存放在这里。记忆使用标准的 Markdown 文件进行存储。

简而言之，记忆听起来很抽象，但它实际上就是智能体可以通过读写来提升工作能力的文件。

### 主动让智能体记住信息

在与智能体合作时，你会不断生成有用的上下文。也许你已经迭代出了一个效果很好的格式，或者明确了你希望如何呈现结果。这些上下文存在于短期记忆中，但它们不必仅限于此。

你可以直接告诉智能体保存它所学到的内容。例如尝试使用以下提示：

*   “这个方法非常有效。更新你的指令，以后始终使用这个方法。”
*   “记住，我更喜欢要点列表而不是长段落。”
*   “将你从这次对话中学到的内容整合到你的记忆中。”

你的智能体会根据反馈更新其长期指令，就像团队成员在高效的工作会议后做笔记一样。随着时间的推移，这意味着你需要做的纠正会越来越少，并且从一开始就能获得更好的结果。

在实践中，这一步并不总是必须的。如果你给出明确的反馈（例如“将你的写作风格改为直接、简洁的散文”），它会意识到这值得记住，并主动提议修改指令，在保存前征求你的同意。但是，当收获不那么明显时（例如你们共同探讨一个问题并最终找到了有效的方法，但从未明确说明），主动让智能体记住这些内容就非常有用。

### 使用“技能”提供专业上下文

“技能（Skills）”是长期记忆的一种形式，但有一个重要的区别：它们只在任务需要时才会被加载。这就像给你的智能体一个参考图书馆，而不是让它预先记住所有东西。智能体看着书架上的书名，只有在相关时才会把书取下来。

这一点很重要，因为上下文并非越多越好。如果智能体试图同时记住所有事情，可能会失去对当前任务重点的关注，从而导致幻觉（Hallucinations）。

举个实际的例子：我有一个用于撰写产品内容的智能体。当撰写关于 LangSmith Deployment 的内容时，我希望它参考该产品的功能、受众和定位；当撰写关于 Agent Builder 的内容时，它需要完全不同的上下文；而当撰写不相关的内容（如 LangChain 即将举办的智能体大会 Interrupt）时，它根本不需要详细的产品上下文。

因此，我为每个产品设置了技能。智能体的核心指令负责处理语气和写作风格，而技能则处理特定于产品的上下文。智能体会根据我正在撰写的内容调用正确的技能，并忽略其他内容。

你可以随时要求智能体创建技能：“创建一个关于 [主题] 的技能，其中包含 [智能体需要的上下文]。”

### 直接编辑智能体的记忆

智能体的指令和配置文件是可以直接访问和编辑的。虽然 Agent Builder 会根据你的反馈自动更新指令，你通常不需要手动操作，但有两个很好的理由值得你考虑直接编辑：

*   **帮助你理解智能体的思维方式**：阅读智能体的指令就像审查团队成员的项目计划。你可以看到智能体是如何处理你的问题的、它优先考虑什么，以及它的假设在哪里可能与你的不符。如果发现问题（如不必要的步骤或错误的假设），你可以直接修复。
*   **有时速度更快**：如果你想更改计划任务的运行时间，或者微调指令中的某一行，直接编辑只需几秒钟。虽然要求智能体进行更改也行得通，但对于小而精确的更新，自己编辑文件往往是最快的途径。

要查看和编辑智能体的指令，你可以直接导航到智能体的记忆文件。

### 总结与开始构建

以上就是让你的智能体随着时间推移变得更聪明的一些简单方法：告诉它要记住什么、赋予它专业的技能，并且不要害怕深入底层直接查看和编辑。

如果你构建了自己喜欢的成果，欢迎在社区 Slack 中与我们分享。

## 相关文档

- [[01-博客/LangChain/我们是如何构建 Agent Builder 记忆系统的|我们是如何构建 Agent Builder 记忆系统的]]；关联理由：上下游；说明：本文讲记忆功能的使用方法，该文补充 Agent Builder 记忆系统的底层设计与工程取舍。
- [[01-博客/LangChain/Deep Agents 的上下文管理|Deep Agents 的上下文管理]]；关联理由：解说；说明：本文提到记忆依赖文件系统与上下文管理，该文详细解释 Deep Agents 的上下文压缩与文件系统机制。
- [[01-博客/LangChain/Agent Builder 中的记忆使用方法|Agent Builder 中的记忆使用方法]]；关联理由：同一事件；说明：两文聚焦同一主题，可用于对照不同版本的表达与结构。

## 关联主题

- [[00-元语/Agent]]
- [[00-元语/memory]]
- [[00-元语/skills]]
- [[00-元语/llm]]
- [[00-元语/virtual-file-system]]
- [[00-元语/context-optimization]]
