# AI 的笨是可知的，小弟的笨是不可知的

## 文档信息
- 来源：https://baoyu.io/blog/ai/ai-dumbness-is-knowable-human-dumbness-is-unknowable
- 发布日期：2024-10-07
- 作者：宝玉

## 摘要

**一句话总结**
一位大厂开发者分享了在无参考的复杂自研项目中应用 AI 辅助编程的实践经验，指出虽然 AI 能力有限且需人工兜底，但其局限性是可预见的，相比初级开发者不可控的低效表现更易于管理。

**核心要点**
*   **项目挑战**：项目面临三大难点，包括使用对 AI 负优化的 Rust 语言、开发无现成参考的特殊设计操作系统，以及大量依赖自研第三方库（如 RPC、异步调用）。
*   **初始阶段表现**：使用通用模型进行代码补全和生成时整体表现不佳，遇到特定领域内容 AI 会“瞎猜”，仅简单的 Tab 补全偶有作用。
*   **微调阶段表现**：将项目代码喂给 LLM 微调后，代码解释效果显著提升，能生成简单的单元测试和基础 setup 代码，但仍需人工修改。
*   **工作流转变**：开发模式从“资深设计+初级开发执行简单工作”转变为“资深设计+AI 执行简单工作”，减少了与初级开发的沟通次数。
*   **核心感悟**：虽然用 AI 替代初级开发有时会让资深开发者感觉更累，但 AI 的“笨”是可预见的，而初级开发的“笨”难以预料（例如曾有初级开发为已跑通的 demo 加两个测试耗时一个月）。

**风险/不足**
*   **领域知识缺失导致幻觉**：通用大模型在对系统一无所知的情况下，遇到特定领域内容会直接“瞎猜”。
*   **新旧组件混淆**：在逐步废弃旧组件、引入新组件的过程中，由于旧组件在代码库中出现频率更高，微调后的 AI 极易将两者混淆。
*   **复杂场景能力差**：AI 在处理复杂的单元测试和 setup 代码时往往“乱来”，几乎无法独立完成，必须依赖人工介入。
*   **增加资深开发者心智负担**：由于 AI 生成的代码准确性不高且需人工兜底，资深开发者在接管 AI 产出后有时会感到更加疲累。

## 正文
**匿名投稿：《AI 的笨是可知的，小弟的笨是不可知的》**

来自一位大厂朋友的经验分享，谈他在用 AI 辅助写代码的感受：

**我们的 AI 写码之旅**

我们的挑战：

1.   **编程语言：Rust**，可以说是“专门为 AI 负优化”的语言。

2.   **产品：特殊设计的操作系统**，几乎没有任何现成的参考。

3.   **自研的第三方库**，包括 RPC、异步调用等，大部分库只有我们自己在用。

我们经历了几次迭代，目前还没有为 Rust 专门调优 LLM。

**初始阶段**

1.   使用通用的代码补全与生成模型做 tab 补全。

2.   使用通用的 Chat 模型进行跨文件代码生成、解释以及生成单元测试等。

这个阶段整体表现不佳。只有 tab 补全在一些简单情况下偶尔能有用。由于 LLM 对我们的系统一无所知，一旦遇到特定领域内容，LLM 就会开始“瞎猜”。

**第二阶段**

我们把项目代码放进去对 LLM 进行微调。

在这一阶段，LLM 勉强理解了一些系统相关的内容，能生成部分相关代码，但准确性依然不高，尤其在我们逐步废弃一些旧组件、引入新组件的过程中，LLM 容易混淆。毕竟当前文件里旧组件的使用频率可能比新组件更高。

简单的单元测试和基础的 setup 代码，LLM 能生成一些，但通常还是需要人工改动；复杂的部分几乎没戏，尤其是 setup，AI 往往“乱来”。

但好的一面是，代码解释的效果好了很多。总结下来就是：它能省下一部分工作量，但离省下全部还有很大差距。

一个明显的好处是，我减少了和初级开发沟通的次数。有些设计，只要我把分割做得足够清晰，给出合适的提示，AI 就能完成个七七八八。

之前的工作流是：我设计、分割，自己搞定难点，把简单的、重复的工作交给小弟，或者写好 demo 再分配任务。

现在的工作流是：我设计、分割，难的部分自己搞定，剩下的交给 AI。说实话，有时候感觉更累了 😂

但至少，AI 的“笨”是可以预见的，而小弟的“笨”却难以预料。

举个例子，有一次我把 demo 都写好了，调试通过，只需要小弟加两个测试就能交付。结果小弟愣是“搞”了一个月... [捂脸]

## 关联主题
- [[00-元语/AI]]
- [[00-元语/llm]]
- [[00-元语/prompt]]
- [[00-元语/workflow]]
- [[00-元语/软件工程]]
