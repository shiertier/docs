---
title: "使用9个并行AI智能体进行代码审查（基于Claude Code）"
发布日期: "2026-02-20"
---

## 摘要

### 一句话总结
基于Claude Code，作者构建了一个包含9个并行子智能体的自动化代码审查工作流，通过多维度独立分析和AI自我验证闭环，大幅提升了代码审查的速度与建议质量。

### 关键要点
* **核心机制**：通过Claude Code启动9个并行的子智能体，每个智能体独立负责代码质量的特定维度，确保审查速度和充足的上下文。
* **结果汇总与评级**：主智能体会将所有发现按严重程度排序汇总，并给出最终结论：准备合并（Ready to Merge）、需要关注（Needs Attention）或需要重做（Needs Work）。
* **9大审查维度**：子智能体分工明确，涵盖测试运行、静态分析、代码审查（最多5个具体建议）、安全性、质量与风格、测试质量（ROI与稳定性）、性能（N+1查询及内存泄漏等）、依赖与部署安全，以及简化与可维护性。
* **数据提升**：该工作流使AI审查建议的有用率提升至约75%（此前低于50%），严重和高优先级的问题反馈几乎总是有效。
* **AI自我迭代闭环**：通过配置 `/code-review` 斜杠命令，要求AI在标记任务“完成”前必须运行此审查并根据反馈进行自我修正，在人工介入前拦截问题。
* **持续优化**：作者将该工作流视为“用Markdown编写代码”，通过不断更新指令来迭代和优化审查标准。

### 风险与不足
* **范围偏移风险**：AI提出的严重（critical）或高优先级（high）问题有时可能会超出当前任务的范围。
* **依赖标准准确性**：AI“闭环”自我验证机制的有效性，完全建立在开发者提供的成功标准必须准确的前提之上。

## 正文

过去几个月，我一直在探索“氛围工程”（vibe engineering），以期简化软件工程的开发周期。我发现人们常遇到的最大问题之一是：如何确保AI做出高质量的代码更改，以及如何以AI生成代码的速度来完成代码审查。

我的答案很简单——让AI完成大部分繁重的工作。

几个月前，我曾分享过一个用AI审查代码的简单脚本。经过多次迭代完善，我现在使用Claude Code的子智能体（subagents）来进行更全面、更符合我需求的代码审查。

### 基于Claude Code子智能体的代码审查

这个审查命令会启动9个并行的子智能体，每个智能体专注于代码质量的特定方面。它们独立分析代码更改，并按严重程度对发现的问题进行排序。主智能体会将所有结果汇总成一份按优先级排列的摘要，并给出最终结论：准备合并（Ready to Merge）、需要关注（Needs Attention）或需要重做（Needs Work）。

我不仅在自己编写的代码上使用这个功能，还要求我的AI智能体在宣布任务“完成”之前，运行这个技能并根据反馈进行迭代——无论是单步迭代，还是长时间运行的自主任务。

反馈质量通常非常好：严重（critical）和高优先级（high）的问题几乎总是很有用（除非超出了范围），中/低优先级的问题通常也是很好的建议。我估计这些建议的有用率约为75%，远高于我以前看到的不到50%的比例。

这些子智能体处理了我经常在AI生成的代码中看到的一类问题。它们还能检查依赖项，或者寻找更简单的实现方式及可去重的现有代码。我非常喜欢并行运行多个智能体，这不仅速度快，还能让每个智能体在其特定任务中使用足够的上下文。

### 9个并行子智能体详解

- **测试运行器（Test Runner）**：执行相关测试，报告通过/失败状态及失败详情。
- **代码检查与静态分析器（Linter & Static Analysis）**：运行linters并收集IDE诊断信息，查找类型错误和未解析的引用。
- **代码审查器（Code Reviewer）**：提供最多5个具体的改进建议，按影响和工作量排序，专注于非明显的问题。
- **安全审查器（Security Reviewer）**：检查注入风险、身份验证问题、代码中的硬编码机密，以及可能泄露敏感信息的错误处理。
- **质量与风格审查器（Quality & Style Reviewer）**：审查代码复杂性、死代码、重复代码以及对项目规范的遵守情况。
- **测试质量审查器（Test Quality Reviewer）**：评估测试覆盖率的投资回报率（ROI）、行为测试与实现测试的对比，以及测试不稳定的风险。
- **性能审查器（Performance Reviewer）**：识别N+1查询、阻塞操作、内存泄漏和昂贵的热点路径。
- **依赖与部署安全审查器（Dependency & Deployment Safety Reviewer）**：审查新依赖项、破坏性更改、迁移安全性以及可观测性。
- **简化与可维护性审查器（Simplification & Maintainability Reviewer）**：思考“这能更简单吗？”，并检查更改是否具有原子性且范围明确。

### 闭环与持续迭代

你可以将完整的代码审查命令放置在 `.claude/commands` 目录中，以便通过斜杠命令 `/code-review` 来运行它。

这种工作流最大的收获是：让AI智能体在标记任务“完成”之前运行此命令并进行迭代——它甚至在我亲自查看代码之前就捕获了问题。增加额外的子智能体进一步提高了反馈的全面性和实用性。

这完美契合了“闭环”（closing the loop）的理念：如果你给AI一种验证自身或确定成功的方法，它就能更好地达成符合这些标准的结果（前提是你的成功标准必须准确）。

我一直在不断迭代我的工作流，这有点像用Markdown编写代码。如果我发现问题或潜在的改进空间，我就会深入其中并更新指令。

## 关联主题

- [[00-元语/AI]]
- [[00-元语/Claude]]
- [[00-元语/Agent]]
- [[00-元语/code-review]]
- [[00-元语/workflow]]
- [[00-元语/vibe-coding]]
- [[00-元语/软件工程]]
