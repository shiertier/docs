---
title: "fastapi-best-practices：FastAPI 工程最佳实践指南"
发布日期: "2026-02-23"
对象: "GitHub 项目 `zhanymkanov/fastapi-best-practices`"
项目主页: "https://github.com/zhanymkanov/fastapi-best-practices"
开源协议: "未声明"
主要语言: "未声明"
统计快照: "Stars 16545，Forks 1211，Watchers 165（抓取时间：2026-02-24）"
---

## 摘要

### 一句话总结
这是一个基于生产环境经验的 FastAPI 最佳实践与代码规范指南，重点涵盖领域驱动的项目结构、并发处理、Pydantic 进阶用法及依赖注入的高级技巧。

### 核心要点
*   **领域驱动的目录结构**：推荐按“业务领域”（如 auth, posts）而非“文件类型”组织代码，每个模块独立包含路由、模型和服务，以提升中大型项目的可扩展性。
*   **路由与并发策略**：明确区分 I/O 密集型与 CPU 密集型任务，详细解析了 `async` 路由（非阻塞 I/O）与 `sync` 路由（线程池）的底层运行差异。
*   **CPU 密集型任务处理**：建议将繁重的计算任务卸载到独立的工作进程（如 Celery 或 `multiprocessing`），以绕过 Python GIL 的限制。
*   **Pydantic 进阶定制**：鼓励深度使用内置验证功能，并建议创建全局自定义基类（Custom Base Model）来统一处理序列化逻辑（如带时区的时间格式）。
*   **配置解耦**：建议将全局的 `BaseSettings` 按模块和业务领域进行拆分，避免配置文件过于臃肿。
*   **依赖注入（Dependencies）复用**：利用依赖注入进行复杂的请求校验（如数据库记录检查），从而减少路由层的重复代码。
*   **依赖项缓存与拆分**：利用 FastAPI 默认的请求级缓存机制（同一请求多次调用只执行一次），安全地将大型依赖拆分为支持链式调用的小函数。
*   **优先使用异步依赖**：推荐优先编写 `async` 依赖项，以避免同步依赖带来的不必要线程池开销。

### 风险与注意事项
*   **事件循环阻塞风险**：严禁在 `async` 路由中执行同步阻塞 I/O（如 `time.sleep()`），这会阻塞整个事件循环，导致服务器在操作完成前无法接收任何新请求。
*   **线程池资源耗尽**：同步路由和同步依赖会在线程池中运行，线程开销高于协程且数量有限，滥用可能导致应用响应变慢。
*   **CPU 密集型任务的局限性**：使用 `await` 或线程池无法优化 CPU 密集型任务，强行使用不会带来任何性能提升。

## 功能与定位

这是一个基于初创公司多年生产环境经验总结的 FastAPI 最佳实践与代码规范指南。该项目旨在分享在构建生产级系统时积累的经验教训，帮助开发者避开常见陷阱，提升开发体验，并构建结构清晰、易于扩展的 FastAPI 应用。

## 典型使用场景

- **中大型项目架构设计**：为包含多个领域和模块的单体应用设计可扩展的目录结构。
- **并发与性能优化**：正确区分并处理 I/O 密集型与 CPU 密集型任务，避免阻塞服务。
- **数据验证与配置管理**：利用 Pydantic 进行复杂的数据清洗、全局模型定制及配置解耦。
- **逻辑复用与请求校验**：通过 FastAPI 的依赖注入系统（Dependencies）进行数据库级别的校验和业务逻辑复用。

## 核心功能

- **项目结构规范**：推荐按“业务领域（Domain）”而非“文件类型”组织代码（灵感来自 Netflix 的 Dispatch 项目）。每个业务模块（如 `auth`, `posts`）内部独立包含路由、模型、服务、配置和异常处理，便于项目扩展。
- **路由与并发处理指南**：
  - **I/O 密集型任务**：详细解析了 `async` 路由（非阻塞 I/O）与 `sync` 路由（由 FastAPI 放入线程池运行）的底层差异及正确使用方式。
  - **CPU 密集型任务**：指出由于 Python GIL 的存在，线程池和协程无法优化 CPU 密集型任务，建议将其卸载到独立的工作进程（如 Celery 或 `multiprocessing`）。
- **Pydantic 进阶策略**：
  - 鼓励深度使用 Pydantic 的内置验证功能（如正则、枚举、邮箱验证）。
  - 建议创建一个全局的自定义基类（Custom Base Model），用于统一处理序列化逻辑（如强制转换带时区的标准时间格式）。
  - 建议将全局的 `BaseSettings` 按模块和领域进行拆分解耦，避免配置臃肿。
- **依赖注入（Dependencies）高级用法**：
  - **超越基础注入**：将依赖项用于复杂的请求验证（如校验数据库中是否存在某条记录），减少路由层面的重复代码。
  - **链式调用与缓存**：支持依赖项调用其他依赖项；利用 FastAPI 默认的请求级缓存机制，确保同一请求中多次调用的依赖项只执行一次，从而安全地将大依赖拆分为小函数。
  - **优先使用 `async` 依赖**：避免同步依赖带来的不必要线程池开销。

## 特色与差异点

- **实战导向与主观性**：内容并非官方文档的简单重复，而是带有强烈主观色彩（Opinionated）的实战经验总结，明确指出了哪些常见做法在大型项目中“无法扩展”。
- **深入底层机制**：在给出规范的同时，解释了背后的运行原理（如事件循环阻塞机制、线程池的资源消耗等），帮助开发者做到知其然并知其所以然。

## 使用方式概览

开发者可将其作为参考手册，对照指南中的目录树示例重构自己的 FastAPI 项目结构；或参考其提供的代码片段，优化项目中的路由定义、Pydantic 模型继承关系以及依赖注入逻辑。

## 限制与注意事项

- **严禁在 `async` 路由中执行阻塞操作**：如果在定义为 `async` 的路由中执行同步阻塞 I/O（如 `time.sleep()`），会阻塞整个事件循环，导致服务器在操作完成前无法接收任何新请求。
- **线程池资源限制**：同步路由和同步依赖会在线程池中运行，而线程的资源开销高于协程，且线程池数量有限，滥用可能导致应用响应变慢。
- **CPU 密集型任务的局限**：不要试图通过 `await` 或线程池来处理繁重的计算任务，这不会带来任何性能提升。

## 链接

- 仓库：https://github.com/zhanymkanov/fastapi-best-practices

## 关联主题

- [[00-元语/fastapi]]
- [[00-元语/learning-resource]]
- [[00-元语/github]]
- [[00-元语/tool]]
